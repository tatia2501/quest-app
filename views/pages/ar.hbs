<!DOCTYPE html>
<head>
  {{>head}}
  <script src="https://unpkg.com/three@0.126.0/build/three.js"></script>
  <script src="libs/artoolkit.min.js"></script>
  <script src="libs/artoolkit.api.js"></script>
  <script src="libs/threex-artoolkitsource.js"></script>
  <script src="libs/threex-artoolkitcontext.js"></script>
  <script src="libs/threex-arbasecontrols.js"></script>
  <script src="libs/threex-armarkercontrols.js"></script>
</head>
<body>
<script>
  var scene, camera, renderer, clock, deltaTime, totalTime;
  var arToolkitSource, arToolkitContext;

  const getMarkers = async () => {
    return await fetch(`/marker`, { method: 'GET' }).then((response) => response.json());
  };

  async function initialize() {
    scene = new THREE.Scene();

    let ambientLight = new THREE.AmbientLight(0xcccccc, 0.5);
    scene.add(ambientLight);

    camera = new THREE.Camera();
    scene.add(camera);

    renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true
    });
    renderer.setClearColor(new THREE.Color('lightgrey'), 0)
    renderer.setSize(640, 480);
    renderer.domElement.style.position = 'absolute'
    renderer.domElement.style.top = '0px'
    renderer.domElement.style.left = '0px'
    document.body.appendChild(renderer.domElement);

    clock = new THREE.Clock();
    deltaTime = 0;
    totalTime = 0;

    arToolkitSource = new THREEx.ArToolkitSource({
      sourceType: 'webcam',
    });

    function onResize() {
      arToolkitSource.onResize()
      arToolkitSource.copySizeTo(renderer.domElement)
      if (arToolkitContext.arController !== null) {
        arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)
      }
    }

    arToolkitSource.init(function onReady() {
      onResize()
    });

    window.addEventListener('resize', function() {
      onResize()
    });

    arToolkitContext = new THREEx.ArToolkitContext({
      cameraParametersUrl: 'libs/camera_para.dat',
      detectionMode: 'mono'
    });

    arToolkitContext.init(function onCompleted() {
      camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
    });

    const data = (await getMarkers()).slice();
    var markerRoots = [];
    var i = 0;

    for (const item of data) {
      markerRoots[i] = new THREE.Group();

      new THREEx.ArMarkerControls(arToolkitContext, markerRoots[i], {
        type: 'pattern', patternUrl: `data/${item.image}.patt`,
      })

      const canvas = document.createElement('canvas')
      const context = canvas.getContext('2d')
      context.fillStyle = 'black'
      context.font = '10px sans-serif'
      context.fillText(`${item.text}`, 90, 90)
      const texture = new THREE.Texture(canvas)
      texture.needsUpdate = true
      var material = new THREE.MeshBasicMaterial({
        map: texture,
        side: THREE.DoubleSide,
      })
      material.transparent = true
      var mesh = new THREE.Mesh(new THREE.PlaneGeometry(3, 3), material)
      mesh.name = 'text'
      mesh.rotation.x = -Math.PI / 2;
      markerRoots[i].add(mesh)
      scene.add(markerRoots[i]);
      i++;
    }
  }

  function update()
  {
    if ( arToolkitSource.ready !== false )
      arToolkitContext.update( arToolkitSource.domElement );
  }

  function render()
  {
    renderer.render( scene, camera );
  }

  function animate()
  {
    requestAnimationFrame(animate);
    deltaTime = clock.getDelta();
    totalTime += deltaTime;
    update();
    render();
  }

  initialize();
  animate();
</script>
</body>
</html>